use intern::{self, InternedString};
use repr::*;
use std::str::FromStr;

grammar;

pub Func: Func = {
    <decls:VarDecl+> <blocks:BasicBlockData+> <asserts:(Comment* <Assertion>)*> => Func {
        decls: decls,
        data: blocks.into_iter()
                    .map(|block| (block.name, block))
                    .collect(),
        assertions: asserts,
    }
};

VarDecl: VarDecl = {
    Comment* "let" <n:Variable> ":" <t:Ty> ";" => VarDecl {
        name: n,
        ty: t,
    }
};

Ty: Ty<()> = {
    <n:Ident> <a:TyArgs> => Ty { name: n, args: a },
};

TyArgs: Vec<TyArg<()>> = {
    "<" <Comma0<TyArg>> ">",
    () => vec![]
};

TyArg: TyArg<()> = {
    "'" => TyArg::Region(()),
    <t:Ty> => TyArg::Ty(t),
};

BasicBlockData: BasicBlockData = {
    Comment* "block" <name:BasicBlock> "{"
        <actions:Action*>
        <gotos:("goto" <BasicBlock*> ";")?>
    "}" => {
        BasicBlockData {
            name: name,
            actions: actions,
            successors: gotos.unwrap_or(vec![]),
        }
    }
};

Action: Action = {
    <a:Variable> "=" "&" <r:RegionName> ";" Comment? => Action::Borrow(a, r),
    <a:Variable> "=" <b:Variable> ";" Comment? => Action::Assign(a, b),
    "use" "(" <v:Variable> ")" ";" Comment? => Action::Use(v),
    ";" Comment? => Action::Noop,
};

Variable: Variable = {
    <n:Ident> => Variable { name: n }
};

Assertion: Assertion = {
    "assert" <n:RegionName> "==" <r:Region> ";" => Assertion::Eq(n, r),
    "assert" <p:Point> "in" <n:RegionName> ";" => Assertion::In(n, p),
    "assert" <p:Point> "not" "in" <n:RegionName> ";" => Assertion::NotIn(n, p),
};

Point: Point = {
    <b:BasicBlock> "/" <a:Usize> => Point { block: b, action: a }
};

Region: Region = {
    "{" <p:Comma0<RegionPart>> "}" => Region {
        parts: p
    }
};

RegionPart: RegionPart = {
    <b:BasicBlock> "/" "[" <start:Usize> ".." <end:Usize> "]" => {
        RegionPart {
            block: b,
            start: start,
            end: end,
        }
    }
};

Usize: usize = {
    r"[0-9]+" => usize::from_str(<>).unwrap()
};

BasicBlock: BasicBlock = {
    Ident => BasicBlock(<>)
};

RegionName: RegionName = {
    r"'[a-zA-Z_]\w*" => RegionName { name: intern::intern(<>) }
};

Ident: InternedString = {
    r"[a-zA-Z_]\w*" => intern::intern(<>)
};

Comma<T>: Vec<T> = {
    <Comma1<T>> ","?
};

Comma0<T>: Vec<T> = {
    <v:Comma<T>?> => v.unwrap_or(vec![])
};

Comma1<T>: Vec<T> = {
    T => vec![<>],
    <v:Comma1<T>> "," <e:T> => {
        let mut v = v;
        v.push(e);
        v
    }
};

Comment: () = {
    r"//.*" => ()
};
