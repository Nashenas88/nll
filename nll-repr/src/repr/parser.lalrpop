use intern::{self, InternedString};
use repr::*;

grammar<'parse, 'arena>(arena: &'parse mut Arena<'arena>);

pub Func: Func<'arena> = {
    <structs:StructData*> <blocks:BasicBlockData+> => Func {
        data: blocks.into_iter()
                    .map(|block| (block.name, block))
                    .collect(),
        structs: structs.into_iter()
                        .map(|s| (s.name, s))
                        .collect(),
    }
};

StructData: StructData = {
    "struct" <name:StructName> "<" <v:Comma<Variance>> ">" => StructData {
        name: name,
        variances: v,
    },
};

Variance: Variance = {
    "+" => Variance::Co,
    "-" => Variance::Contra,
    "o" => Variance::In,
};

BasicBlockData: BasicBlockData<'arena> = {
    "block" <name:BasicBlock> "{"
        <actions:Action*>
        <gotos:("goto" <BasicBlock*> ";")?>
    "}" => {
        BasicBlockData {
            name: name,
            actions: actions,
            successors: gotos.unwrap_or(vec![]),
        }
    }
};

BasicBlock: BasicBlock = {
    Ident => BasicBlock(<>)
};

StructName: StructName = {
    Ident => StructName(<>)
};

Action: Action<'arena> = {
    <a:Ty> "<:" <b:Ty> ";" => Action::Subtype(a, b),
    "*" <r:Ty> ";" => Action::Deref(r),
};

Ident: InternedString = {
    r"[a-zA-Z_]\w*" => intern::intern(<>)
};

Atom: Atom<'arena> = {
    Ty => Atom::Type(<>),
    Region => Atom::Region(<>),
};

Ty: Ty<'arena> = {
    TyData => arena.intern(<>),
};

TyData: TyData<'arena> = {
    "usize" => TyData::Usize,
    <n:StructName> "<" <a:Atom*> ">" => TyData::StructRef(StructRef {
        name: n,
        substitutions: a,
    }),
    "&" <r:Region> <m:"mut"?> <t:Ty> => TyData::Reference(Reference {
        region: r,
        mutability: m.map(|_| Mutability::Mut).unwrap_or(Mutability::NotMut),
        ty: t,
    }),
    <n:Ident> => {
        intern::read(|i| {
            if i.data(n).chars().all(|c| c.is_numeric() || c.is_uppercase()) {
                TyData::Parameter(n)
            } else {
                TyData::StructRef(StructRef {
                    name: StructName(n),
                    substitutions: vec![]
                })
            }
        })
    },
};

Region: Region<'arena> = {
    RegionData => arena.intern(<>),
};

RegionData: RegionData = {
    "{" <entry:BasicBlock> "->" <exits:Comma<RegionExit>> "}" => RegionData {
        entry: entry,
        exits: exits,
    }
};

RegionExit: RegionExit = {
    "'" <Ident> => RegionExit::Parameter(<>),
    BasicBlock => RegionExit::Block(<>),
};

Comma<T>: Vec<T> = {
    <Comma1<T>> ","?
};

Comma1<T>: Vec<T> = {
    T => vec![<>],
    <v:Comma1<T>> "," <e:T> => {
        let mut v = v;
        v.push(e);
        v
    }
};
