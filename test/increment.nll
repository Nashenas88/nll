let p;

block START {
    p = &;    // let p = &mut i;
    ;         // print(i);
    write(p); // *p += 1;
    ;         // print(i);
    write(p); // *p += 1;
    ;         // i = 10;    
}

// p is dead at final `;` but active before
assert p@START/1.0 == { START/1, START/2, START/3, START/4 };

// p is writable in two spots
assert p@START/1.1 == { START/2, START/4 };
