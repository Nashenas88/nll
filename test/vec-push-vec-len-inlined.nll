let p;
let q;
let r;

block START {
    p = &;    // let p = &mut vec;
    q = &;    // let q = &vec;
    use(q);   // let tmp = Vec::len(q);
    r = p;
    goto VEC_PUSH_START;
}

block VEC_PUSH_START {
    write(r);
    write(r);
    write(r);
    goto VEC_PUSH_RET;
}

block VEC_PUSH_RET {
}

// p does not require exclusive access during START/1 or START/2
assert START/1 not in p@START/1.1;
assert START/2 not in p@START/1.1;

// p DOES require *shared* access at those times:
assert START/1 in p@START/1.0;
assert START/2 in p@START/1.0;

// p DOES require exclusive access during VEC_PUSH_START
// (indirectly, because of writes through `r`):
assert VEC_PUSH_START/0 in p@START/1.1;
assert VEC_PUSH_START/1 in p@START/1.1;
assert VEC_PUSH_START/2 in p@START/1.1;
assert VEC_PUSH_START/2 in p@START/1.0;

// q is dead at START/3:
assert VEC_PUSH_START/0 not in q@START/2.0;
